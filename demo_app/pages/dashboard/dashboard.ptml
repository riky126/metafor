@page('', "Dashboard") @props {
    import asyncio
    from js import console
    from contexts import DBContext, ThemeContext
    from metafor.hooks import create_memo, use_context, create_effect
    from metafor.core import batch_updates, create_signal, on_dispose, on_mount
    from metafor.utils import run_async
    from services import fetch_account
    from metafor.storage import Indexie, use_live_query
    from db import db

    theme = use_context(ThemeContext)

    def mounted():
        print("Dashboard Page mounted!")
        run_async(
            fetch_account
        )
    
    # on_mount (executed when the component is added to the DOM)
    on_mount(mounted)

    def dispose_home():
        print("Dashboard Page disposed!")

    # on_dispose (executed when the component is removed from the DOM)
    on_dispose(dispose_home)

    user_data, set_user_data = create_signal({
        "name": "Alice",
        "profile": {
            "age": 30,
            "roles": ["user"]
        }
    }, deep=True)

    # Create an effect that will track changes
    def user_effect():
        print(f"User changed: {user_data()}")

    create_effect(user_effect)
    # These should now all trigger the effect:
   
    # These updates will now trigger the effect without changing references
    def update_person(e):
        print("Updating person...")
        def update():
            user_data()["name"] = "Bob"
            user_data()["profile"]["age"] += 1
            user_data()["profile"]["roles"].append("admin")

        batch_updates(lambda: [
            update()
        ])

    
    # --- Reactive Query Example ---
    # This list will automatically update when 'users' table changes.
    users_list = use_live_query(lambda: db.users.to_array())

    async def add_random_user():
        import random
        n = random.randint(1, 10000)
        
        console.log("Starting Optimistic Transaction...")
        async with db.users.start_transaction(optimistic=True) as tx:
             # 1. Add to Overlay (UI updates immediately)
             await db.users.add({"name": f"User {n}", "email": f"user{n}@test.com"})
             console.log(f"Added User {n} (Overlay) - UI should update now.")
             
             # 2. Simulate Network Delay
             await asyncio.sleep(3) 
             
             # 3. Commit (Persist to IDB)
             await tx.commit()
             console.log(f"Committed User {n} to IndexedDB.")

    def on_add_click():
        asyncio.create_task(add_random_user())
        
    async def clear_users():
        await db.users.clear()
        
    def on_clear_click():
        asyncio.create_task(clear_users())
}

@ptml {
    <div className="home">
        <div className=@{lambda: f'theme-{theme()}'} onclick=@{update_person} >
            <h2>Dashboard Page</h2>
            <p>Welcome to the home page!</p>

            @{lambda: user_data()}
        </div>

        <!-- Reactive Usage Demo -->
        <div className=@{lambda: f'db-container theme-{theme()}'} style="padding: 20px; border-top: 2px solid #eeeeeeff; margin-top: 20px;">
            <h3>Reactive Indexie Demo</h3>
            <div style="margin-bottom: 10px;">
                <sl-button onClick=@{on_add_click}>Add Random User</sl-button>
                <sl-button onClick=@{on_clear_click} style="margin-left: 10px;">Clear All</sl-button>
            </div>
            
            <div>
                <strong>Total Users: @{lambda: len(users_list() or [])}</strong>
                <ul>
                    @foreach u in users_list, key=lambda u, _: u.get('id') {
                        <li>@{u.get('name')} (@{u.get('email')})</li> 
                    } -> @fallback {
                        <li>No users found</li>
                    }
                </ul>
            </div>
        </div>

    </div>
}